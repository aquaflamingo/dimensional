import { useState, Suspense } from "react";
import Head from "next/head";
import { useEffect } from "react";
import { BaseURL, GetProfileSummary, ListProfiles } from "../utils/urls";
import Image from "next/image";
import SearchBar from "../components/Search";

export default function Home() {
  return (
    <>
      <Head>
        <title>Dimensional</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main>
        <div className="container mx-auto z-0">
          <Navbar />
          <Profile />
        </div>
      </main>
    </>
  );
}

const Navbar = () => {
  return (
    <nav className="px-2 sm:px-4 py-2.5 rounded h-32 z-10">
      <div className="container md:flex flex-wrap items-center md:justify-between mx-auto">
        <a href="#" className="flex items-center">
          <Image src="/logo.png" width="100" height="54" />
        </a>
        <div
          className="w-auto md:block md:w-auto py-5 h-32"
          id="navbar-default"
        >
          <SearchBar />
        </div>
      </div>
    </nav>
  );
};

type ElementSVGProps = {
  fill: string;
};

const ElementSVG = ({ fill }: ElementSVGProps) => {
  return (
    <div className="flex w-full justify-center">
      <svg width="64" height="64">
        <circle
          cx="32"
          cy="32"
          r="15"
          stroke={fill}
          strokeWidth="24"
          fill="none"
        />
      </svg>
    </div>
  );
};

type ElementCellProps = {
  fill: string;
  element: string;
};

const ElementCell = ({ element, fill }: ElementCellProps) => {
  // TODO style
  return (
    <div className="box-border h-32 p-4 border-2 md:w-32">
      <ElementSVG fill={fill} />
      <p className="text-center text-xs">{element}</p>
    </div>
  );
};

//  and elements are the same?
export interface Element {
  name: string;
  colorHexCodes: string[];
  score: number | null;
}

type EndorsedElementsGridProps = {
  elements: Element[];
};

const EndorsedElements = ({ elements }: EndorsedElementsGridProps) => {
  const renderCells = (elements: Element[]) => {
    let results = [];

    for (let i = 0; i < elements.length; i++) {
      let t = elements[i];
      let fill = t.colorHexCodes.length > 0 ? t.colorHexCodes[0] : "#FFF";

      results.push(
        <li className="list-none" key={i}>
          <ElementCell element={t.name} fill={fill} />
        </li>
      );
    }

    return results;
  };

  return (
    <div>
      <h3 className="text-lg py-2">Most Endorsed Elements</h3>
      <div className="md:grid md:grid-cols-6 flex overflow-x-auto gap-1">
        {elements && elements.length > 0
          ? renderCells(elements)
          : "No elements found"}
      </div>
    </div>
  );
};

type PersonalityDescriptorCellProps = {
  trait: Descriptor;
};

const PersonalityDescriptorCell = ({
  trait,
}: PersonalityDescriptorCellProps) => {
  // TODO slashes missing and highlight
  const renderDescriptorValue = (tv: DescriptorValue[]) => {
    let results = tv.map((tv: DescriptorValue) => {
      if (!tv.highlighted) {
        return <span className="text-gray-500">{tv.text} </span>;
      } else {
        return <span className="decoration-white">{tv.text} </span>;
      }
    });

    return results;
  };

  return (
    <div className="grid grid-cols-2 py-2 border-solid border-2 border-sky-50">
      <div className="text-left px-2">
        <p>{trait.name}</p>
      </div>
      <div className="text-right px-2">
        <p>{renderDescriptorValue(trait.values)}</p>
      </div>
    </div>
  );
};

interface DescriptorValue {
  text: string;
  highlighted: boolean;
}

interface Descriptor {
  name: string;
  values: DescriptorValue[];
}

const PersonalityDescriptorList = ({
  traits,
}: PersonalitySummaryTableProps) => {
  const renderCells = (traits: Descriptor[]) => {
    let results = [];

    for (let i = 0; i < traits?.length; i++) {
      let t = traits[i];

      results.push(
        <li key={i}>
          <PersonalityDescriptorCell trait={t} />
        </li>
      );
    }

    return results;
  };

  return (
    <ul className="list-none">
      {traits && traits.length > 0 ? (
        renderCells(traits)
      ) : (
        <p>No traits found</p>
      )}
    </ul>
  );
};

type PersonalitySummaryTableProps = {
  traits: Descriptor[];
};

const PersonalitySummaryTable = ({ traits }: PersonalitySummaryTableProps) => {
  return (
    <div>
      <div>
        <h3 className="text-lg bg-gray-50 text-black px-2 py-2">
          Personality Summary
        </h3>
      </div>
      <PersonalityDescriptorList traits={traits} />
    </div>
  );
};

type AdjectivesListProps = {
  adjectives: string[];
};

const AdjectivesList = ({ adjectives }: AdjectivesListProps) => {
  return (
    <div>
      <h3 className="text-lg">Adjectives</h3>
      <p>
        {adjectives && adjectives.length > 0
          ? adjectives.join(", ")
          : "No adjectives given"}
      </p>
    </div>
  );
};

type ProfileContentProps = {
  // TODO
  profile: UserProfileResponse;
  personality: UserPersonalityResponse;
};

const ProfileContent = ({ personality, profile }: ProfileContentProps) => {
  const adjs: string[] = profile?.adjectives;
  const elements: Element[] = profile?.mostEndorsedElements;
  const descriptors: Descriptor[] = personality.summaryTableRows.map((row) => {
    let values: DescriptorValue[] = row.values.map((v) => {
      return { text: v.text, highlighted: v.isHighlighted };
    });

    return { name: row.title, values: values };
  });

  return (
    <div className="col-span-3 py-3 space-y-4 px-5 md:px-10">
      <ProfileHeader
        userName={profile?.userName}
        profileUrl={profile?.profileUrl}
      />
      <PersonalitySummaryTable traits={descriptors} />
      <EndorsedElements elements={elements} />
      <AdjectivesList adjectives={adjs} />
    </div>
  );
};

type ProfileHeaderProps = {
  userName: string;
  profileUrl: string;
};

const ProfileHeader = ({ userName, profileUrl }: ProfileHeaderProps) => {
  return (
    <div className="space-y-1">
      <h1 className="text-5xl">{userName}</h1>
      <h2 className="text-lg">{profileUrl}</h2>
    </div>
  );
};

interface UserProfileResponse {
  description: string;
  userName: string;
  profileUrl: string;
  adjectives: string[];
  id: string;
  mostEndorsedElements: Element[];
}

interface SummaryTableValue {
  text: string;
  isHighlighted: boolean;
}

interface SummaryTableRow {
  title: string;
  values: SummaryTableValue[];
}

interface UserPersonalityResponse {
  summaryTableRows: SummaryTableRow[];
}

type SuspenseLoaderProps = {
  message: string;
};

const SuspenseLoader = ({ message }: SuspenseLoaderProps) => {
  return <div className="text-white">{message}</div>;
};

const Profile = () => {
  const [profile, setProfile] = useState<UserProfileResponse>();
  const [personality, setPersonality] = useState<UserPersonalityResponse>();
  const [error, setError] = useState();

  // Fetch profile
  // componentDidMount
  useEffect(() => {
    const profileURL = BaseURL + ListProfiles;
    fetch(profileURL)
      .then((r) => r.json())
      .then((r) => {
        console.log("Fetched profile");
        // Single profile
        setProfile(r[0]);
      })
      .catch((err) => {
        console.error(`Error fetching Profile:`, err);
        setError(err);
      });
  }, []);

  // Fetch personality
  // Triggers on each profile change
  useEffect(() => {
    if (profile === undefined) return;

    const personalityUrl = BaseURL + GetProfileSummary(profile!.id);
    fetch(personalityUrl)
      .then((r) => r.json())
      .then((r) => {
        console.log("Fetched personality");
        // Single profile
        setPersonality(r);
      })
      .catch((err) => {
        console.error(`Error fetching personality:`, err);
        setError(err);
      });
  }, [profile]);

  return (
    <Suspense fallback={SuspenseLoader}>
      {error && (
        <p className="bg-red text-white">Error fetching profile: {error}</p>
      )}

      {profile && personality && (
        <div className="md:grid md:grid-cols-4 md:gap-5 px-5 z-0">
          <ProfileBio description={profile.description} />
          <ProfileContent personality={personality} profile={profile} />
        </div>
      )}
    </Suspense>
  );
};

type ProfileImageProps = {
  src: string;
};

const ProfileImage = ({ src }: ProfileImageProps) => {
  return (
    <div className="justify-center w-full py-5 flex">
      <Image
        src={src}
        width="150"
        height="150"
        className="rounded-full shadow-sm"
        alt=""
      />
    </div>
  );
};

type ProfileSummaryProps = {
  description: string;
};

const ProfileBio = ({ description }: ProfileSummaryProps) => {
  // None given in the API
  const profileImage = "/profileimage.png";

  return (
    <div className="col-span-1">
      <ProfileImage src={profileImage} />
      <p className="md:text-left sm:text-center px-5">
        {description ? description : "No description provided"}
      </p>
    </div>
  );
};
